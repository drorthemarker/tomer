// Check if the analysisData object from analysis_data.js was loaded correctly.
if (typeof analysisData === 'undefined') {
    alert("Error: analysis_data.js could not be loaded. Make sure it is in the same folder as index.html.");
}

// Get the two critical pieces of information generated by Python.
const annotatedImageUrl = analysisData.annotatedImageUrl;
const pixelsPerCm = analysisData.pixelsPerCm;

// --- CORE LOGIC ---

const canvas = document.getElementById('measurement-canvas');
const ctx = canvas.getContext('2d');

let isDrawing = false;
let startPoint = { x: 0, y: 0 };
let currentPoint = { x: 0, y: 0 };
let savedLines = []; // Array to store all the lines the user has drawn

// 1. Load the pre-annotated image onto the canvas
const baseImage = new Image();
baseImage.src = annotatedImageUrl;
baseImage.onload = () => {
    // Set the canvas's internal resolution to match the image's actual size
    canvas.width = baseImage.width;
    canvas.height = baseImage.height;
    // Draw the image to fill the canvas
    redraw();
};

// 2. Add Event Listeners for both Mouse and Touch
canvas.addEventListener('mousedown', handleStart, { passive: false });
canvas.addEventListener('mousemove', handleMove, { passive: false });
canvas.addEventListener('mouseup', handleEnd, { passive: false });
canvas.addEventListener('mouseout', handleEnd, { passive: false }); // Stop drawing if mouse leaves canvas

canvas.addEventListener('touchstart', handleStart, { passive: false });
canvas.addEventListener('touchmove', handleMove, { passive: false });
canvas.addEventListener('touchend', handleEnd, { passive: false });

// 3. Handler Functions
function handleStart(e) {
    e.preventDefault(); // Prevent default browser actions (like scrolling or zooming)
    isDrawing = true;
    startPoint = getEventPosition(e);
}

function handleMove(e) {
    if (!isDrawing) return;
    e.preventDefault();
    currentPoint = getEventPosition(e);
    
    // Redraw everything to show the live preview line
    redraw();
    drawMeasurement(startPoint, currentPoint, 'red', true); // true = is temporary
}

function handleEnd(e) {
    if (!isDrawing) return;
    e.preventDefault();
    isDrawing = false;

    // Save the finalized line
    const finalPoint = getEventPosition(e) || currentPoint; // Use last known point if event has no position
    // Only save if it's a meaningful line, not just a tap
    if (getDistance(startPoint, finalPoint) > 10) {
        savedLines.push({ start: startPoint, end: finalPoint });
    }
    
    // Redraw everything with the final line now part of the saved lines
    redraw();
}

// 4. Drawing and Calculation Functions

// This function clears and redraws the entire canvas state
function redraw() {
    // Clear the canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Draw the base image (with green/purple lines)
    ctx.drawImage(baseImage, 0, 0);
    // Draw all the previously saved manual lines
    savedLines.forEach(line => {
        drawMeasurement(line.start, line.end, 'red', false); // false = is permanent
    });
}

// A single function to draw a line and its measurement text
function drawMeasurement(p1, p2, color, isTemporary) {
    // Draw the line
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.strokeStyle = color;
    ctx.lineWidth = 4; // A good thickness for mobile
    ctx.stroke();

    // Calculate the distance
    const pixelDistance = getDistance(p1, p2);
    if (pixelDistance === 0) return; // Don't draw text for a single point
    
    const cmDistance = pixelDistance / pixelsPerCm;

    // Draw the text with a background
    const text = `${cmDistance.toFixed(1)} cm`;
    ctx.font = '32px Arial';
    ctx.fillStyle = 'white';
    
    const textWidth = ctx.measureText(text).width;
    const textX = p2.x + 10;
    const textY = p2.y - 10;
    
    ctx.fillRect(textX - 5, textY - 32, textWidth + 10, 40); // White background
    ctx.fillStyle = color;
    ctx.fillText(text, textX, textY);
}

// --- Helper Functions ---

// A universal function to get coordinates from either a mouse or touch event
function getEventPosition(e) {
    const rect = canvas.getBoundingClientRect();
    let clientX, clientY;

    if (e.touches && e.touches.length > 0) {
        // Touch event
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
    } else {
        // Mouse event
        clientX = e.clientX;
        clientY = e.clientY;
    }

    if (clientX === undefined || clientY === undefined) return null;

    // This important step scales the on-screen touch/click position to the
    // actual pixel coordinates on the full-resolution canvas image.
    return {
        x: (clientX - rect.left) * (canvas.width / rect.width),
        y: (clientY - rect.top) * (canvas.height / rect.height)
    };
}

function getDistance(p1, p2) {
    if (!p1 || !p2) return 0;
    return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}
